# ZETA MATRIX
# Created by Justin Lee on the 14th of September, 2023 
# Occupation
# Have you completed or recieved an internship from a trading company 
# Should measure something deeper than 'are quant traders better at ____' 
# but... should measure learning curve. yes. How about each cell is a stack. It measures the average increment 
# Could investigate learning curve...
# Investigate learnings curves and use an index. yes. okay gonna have to keep their speed score and an index. 
# i create fun minigames that are disguised tools to prove economic theories such as risk aversion, or behavioral biases, or just other interesting data insights - e.g what is the hardest combination of sum. 
# Time complexity
# Interestingly: this is a good data structure problem
# I'm thinking since I need to construct the zeta matrix but also have timestamped questions... 
# A .csv of timestamp, num1, operator, num2, timetaken
# Then iterate down this list and construct the zetamatrix 
# Then it will be one continuous... time series. 
# Lets say you have n questions complete. 
# hypothesis test: the previous one taking long results in the next one.
# Could implement an enter button... nah that's not zetamac. 

# 1 = +, 2 = -, 3 = *, 4 = /
#  ⣿

# Cache the matrix for computation. (save the timestamp that it got up to.) No even easier - the zetamatrix itself is simply the best time... yeah

from curses.textpad import Textbox, rectangle
import curses
import json
import datetime
import random
import re
import csv
import time

class CSVAppender:
    def __init__(self, filename='/Users/justinlee/Documents/projport/s9-quant/data.csv'):
        self.filename = filename
        self.file = open(filename, 'a', newline='')
        self.writer = csv.writer(self.file)

        # Check if the file already has content
        # If not, write headers
        if self.file.tell() == 0:
            self.writer.writerow(["timestamp", "num1", "operator", "num2", "timetaken", "got_wrong"])

    def append(self, timestamp, num1, operator, num2, timetaken, got_wrong):
        self.writer.writerow([timestamp, num1, operator, num2, timetaken, got_wrong])
        # If you want to ensure data is written immediately (not buffered), uncomment next line:
        # self.file.flush()

    def close(self):
        self.file.close()

zetaMatrix_add = [['inf' for _ in range(2, 101)] for _ in range(2, 101)]
zetaMatrix_sub = [['inf' for _ in range(2, 101)] for _ in range(2, 101)]
zetaMatrix_mult = [['inf' for _ in range(2, 101)] for _ in range(2, 13)]
zetaMatrix_divi = [['inf' for _ in range(2, 101)] for _ in range(2, 13)]

def generate_question(decimals = False):
    op_list = ['+', '-', '*', '/']
    oper = random.choice(op_list)

    #if difficulty == 1:  # One decimal place

    if not decimals: 
        add_range = [(2, 100), (2, 100)]
        mult_range = [(2, 12), (2, 100)]
        
        # fill in here 
        if oper in ['+', '-']:
            num1 = random.randint(add_range[0][0], add_range[0][1])
            num2 = random.randint(add_range[1][0], add_range[1][1])

        elif oper == "*": 
            num1 = random.randint(mult_range[0][0], mult_range[0][1])
            num2 = random.randint(mult_range[1][0], mult_range[1][1])
            answer = eval(f"{num1} {oper} {num2}")

        elif oper == "/": 
            num2 = random.randint(mult_range[0][0], mult_range[0][1])
            num1 = random.randint(mult_range[1][0], mult_range[1][1])
            product = num1 * num2
            answer = num1
            num1 = product

    return num1, oper, num2

def draw_box(stdscr, y, x, height, width):
    h_max, w_max = stdscr.getmaxyx()
    if y + height >= h_max or x + width >= w_max:
        return  
    
    # Draw the top and bottom
    stdscr.addch(y, x, curses.ACS_ULCORNER)
    stdscr.addch(y, x + width, curses.ACS_URCORNER)
    stdscr.addch(y + height, x, curses.ACS_LLCORNER)
    stdscr.addch(y + height, x + width, curses.ACS_LRCORNER)

    # Draw the sides
    for i in range(y+1, y + height):
        stdscr.addch(i, x, curses.ACS_VLINE)
        stdscr.addch(i, x + width, curses.ACS_VLINE)

    # Draw the top and bottom
    for i in range(x+1, x + width):
        stdscr.addch(y, i, curses.ACS_HLINE)
        stdscr.addch(y + height, i, curses.ACS_HLINE)

def draw_home(stdscr):

    # Set up TUI 
    stdscr.clear()
    draw_box(stdscr, 0, 0, 25, 60)
    for w in range(5, 55):
        for h in range(4, 24):
            stdscr.addch(h, w, "░") #⣿

    for i in range(1, 60): 
        stdscr.addch(3, i, curses.ACS_HLINE) 
    stdscr.addch(3, 0, curses.ACS_LTEE) 
    stdscr.addch(3, 60, curses.ACS_RTEE) 

    stdscr.addstr(0, 2, " ζ-ZetaMatrix ", curses.A_STANDOUT)


    stdscr.refresh()





    # Start zeta-matrix
    while True: 
        stdscr.addstr(2, 15, "Tap any key 3 times to begin")
        key = stdscr.getch()
        key = stdscr.getch()
        key = stdscr.getch()
        stdscr.addstr(2, 15, "                             ")
        play_zeta(stdscr)
        
def play_zeta(stdscr):

    # Waits for '_' space to start 
    # 1 second pause and then the first question 

    appender = CSVAppender()
    stdscr.addstr(2, 15, " Ready? ")
    stdscr.refresh()
    time.sleep(0.75)
    
    # Make cursor visible
    curses.curs_set(2)    
    while True: 
        time_recent = time.time()
        got_wrong = False
        score = 0  # This isn't used, but it's initialized here. You might want to update or use it somewhere.
        
        answer_str = ''
        
        # Assuming generate_question() returns num1, oper, num2 in that order.
        num1, oper, num2 = generate_question()
        question = f"{num1} {oper} {num2}"
        ans = eval(question)

        stdscr.addstr(2, 15, f"> {question} =      ")
        stdscr.move(2, 20 + len(question))
        stdscr.refresh()
        
        while True: 
            elapsed_time = time.time() - time_recent

            key = stdscr.getch()

            if key == curses.KEY_ENTER or key == 10 or key == 13:
                pass
            elif key in [curses.KEY_BACKSPACE, ord('\b'), ord('\x7f')]:
                if len(answer_str) > 0:
                    answer_str = answer_str[:-1]
                    stdscr.addstr(2, 20 + len(question) + len(answer_str), ' ')
                    stdscr.refresh()
            elif len(answer_str) + 1 < 10 and (chr(key).isdigit() or chr(key) in ['-', '.']):
                answer_str += chr(key)
            
            stdscr.addstr(2, 20 + len(question), answer_str)
            stdscr.refresh()
            
            # Check whether the answer is correct 
            try:
                if int(answer_str) == 9999:
                    appender.close()
                    return
                
                if int(answer_str) == ans:
                    time_taken = round(time.time() - time_recent, 3)
                    if time_taken > 90: break # Anything over 90 seconds is considered errenous (sorry)
                    
                    appender.append(time.time(), num1, oper, num2, time_taken, got_wrong)
                    # Print to screen for diagnostics
                    # stdscr.addstr(1, 40, f"{num1}, {num2}, {time_taken}s   ")
                    # stdscr.addstr(1, 59, f"⏲")

                    stdscr.refresh()
                    time_recent = time.time()
                    break  # Go to the next question
                if len(answer_str) >= len(str(ans)):
                    got_wrong = True

                

            except ValueError:
                continue 

    return 

def draw_zetaMatrix(stdscr, type='add'):

    # First, clear the area (just to be safe) 
    # Now, draw the corresponding 
    # for _ in 
    return 

def main(stdscr):
    # Initialize color support
    curses.start_color()
    
    # Initialize color pairs (Foreground: White, Background: Black)
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
    curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_WHITE)  
    curses.init_pair(3, curses.COLOR_RED, curses.COLOR_WHITE) 
    curses.init_pair(4, curses.COLOR_WHITE, curses.COLOR_RED)

    # Apply the color pair to stdscr
    stdscr.bkgd(' ', curses.color_pair(1))  
    
    # Screen dimensions
    h, w = 25, 60
    h_min, w_min = h, w

    # Screen sizing loop
    while True:
        stdscr.clear()
        h_curr, w_curr = stdscr.getmaxyx()
        if h_curr <= h_min or w_curr <= w_min:
            # Show a live read of the screen size 
            stdscr.addstr(0, 0, "Please resize the window to at least 25x60")
            stdscr.addstr(1, 0, f"Currently: {h_curr:3} x {w_curr:3}")
            stdscr.addstr(2, 0, "You may use ⌘- / ⌘+")
        else:
            break

        # Refresh the screen
        stdscr.refresh()
    
    draw_home(stdscr)

    # CENTRAL LOOP 
    
    
# Start 
if __name__ == "__main__":
    curses.wrapper(main)


# Refresht he screen buttonso beautiful. How do they do it. 